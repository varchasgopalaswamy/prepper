"""
This type stub file was generated by pyright.
"""

from __future__ import annotations

from .util import require_keywords

r"""

Neutron scattering factors for the elements and isotopes.

For details of neutron scattering factor values, see :class:`Neutron`.
The property is set to *None* if there is no neutron scattering information
for the element. Individual isotopes may have their own scattering
information.

Example
=======

Print a table of coherent scattering length densities for isotopes
of a particular element:

.. doctest::

    >>> import periodictable
    >>> for iso in periodictable.Ni:
    ...     if iso.neutron.has_sld():
    ...         print("%s %7.4f"%(iso,iso.neutron.sld()[0]))
    58-Ni 13.1526
    60-Ni  2.5575
    61-Ni  6.9417
    62-Ni -7.9464
    64-Ni -0.3379


Details
=======

There are a number of functions available in periodictable.nsf

    :func:`neutron_energy`
        Return neutron energy given wavelength.

    :func:`neutron_wavelength`
        Return wavelength given neutron energy.

    :func:`neutron_wavelength_from_velocity`
        Return wavelength given neutron velocity.

    :func:`neutron_scattering`
        Computes scattering length density, cross sections and
        penetration depth for a compound.

    :func:`neutron_sld`
        Computes scattering length density for a compound.

    :func:`neutron_composite_sld`
        Returns a scattering length density for a compound whose composition
        is variable.

    :func:`energy_dependent_table`
        Lists isotopes with energy dependence.

    :func:`sld_table`
        Lists scattering length densitys for all elements in natural abundance.

    :func:`absorption_comparison_table`
        Compares the imaginary bound coherent scattering length to the
        absorption cross section.

    :func:`coherent_comparison_table`
        Compares the bound coherent scattering length to the
        coherent scattering cross section.

    :func:`total_comparison_table`
        Compares the total scattering cross section to the sum of the
        coherent and incoherent scattering cross sections.

For private tables use :func:`init` to set the data.

The neutron scattering information table is reproduced from the Atomic
Institute for Austrian Universities\ [#Rauch2003]_  (retrieve March 2008):

http://www.ati.ac.at/~neutropt/scattering/table.html

The above site has references to the published values for every entry in
the table.  We have included these in the documentation directory
associated with the periodictable package.

.. Note:

   Enteries in the table have been measured independently, so the values
   measured for the scattering length of an element or isotope may be
   inconsistent with the values measured for the corresponding cross section.

.. [#Rauch2003] Rauch, H. and Waschkowski, W. (2003)
    Neutron Scattering Lengths in ILL
    Neutron Data Booklet (second edition), A.-J. Dianoux, G. Lander, Eds.
    Old City Publishing, Philidelphia, PA. pp 1.1-1 to 1.1-17.
    (https://www.ill.eu/fileadmin/user_upload/ILL/1_About_ILL/Documentation/NeutronDataBooklet.pdf)

.. [#Rauch2000] Rauch, H. and Waschkowski, W. (2000)
    Neutron scattering lengths. Schopper, H. (ed.). SpringerMaterials -
    The Landolt-Börnstein Database (http://www.springermaterials.com).
    doi: 10.1007/10499706_6

.. [#Koester1991] Koester, L., Rauch, H., Seymann. E. (1991)
    Atomic Data Nuclear Data Tables 49, 65. doi:10.1016/0092-640X(91)90012-S

.. [#Lynn1990] Lynn, J.E. and Seeger, P.A. (1990)
    Resonance effects in neutron scattering lengths of rare-earth nuclides.
    Atomic Data and Nuclear Data Tables 44, 191-207.
    doi:10.1016/0092-640X(90)90013-A

.. [#Sears2006] Sears, V. F. (2006)
    4.4.4 Scattering lengths for neutrons.
    In Prince, E. ed. Intl. Tables for Crystallography C.
    Kluwer Academic Publishers. pp 444-454.
    (https://it.iucr.org/Cb/ch4o4v0001/sec4o4o4/)
    doi: 10.1107/97809553602060000103

.. [#Sears1992] Sears, V.F. (1992)
    Neutron scattering lengths and cross sections.
    Neutron News 3, No. 3, 26-37.

.. [#May1982] May, R.P.,  Ibel, K. and Haas, J. (1982)
    The forward scattering of cold neutrons by mixtures of light and heavy water.
    J. Appl. Cryst. 15, 15-19. doi:10.1107/S0021889882011285

.. [#Mildner1998] Mildner, D.F.R., Lamaze, G.P. (1998)
   Neutron Transmission of Single-Crystal Sapphire.
   J Appl Crystallogr 31, 835–840. doi:10.1107/S0021889898005846

.. [#Smith2006] Smith, G.S. and Majkrzak, C.M. (2006)
    2.9 Neutron reflectometry.
    In E. Prince ed. Intl. Tables for Crystallography C.
    Wiley InterScience. pp 126-146. doi: 10.1107/97809553602060000584

.. [#Glinka2011] Glinka, C.J. (2011)
    Incoherent Neutron Scattering from Multi-element Materials.
    J. Appl. Cryst. 44, 618-624. doi: 10.1107/S0021889811008223
"""
__all__ = [
    "init",
    "Neutron",
    "neutron_energy",
    "neutron_wavelength",
    "neutron_wavelength_from_velocity",
    "neutron_scattering",
    "neutron_sld",
    "neutron_composite_sld",
    "sld_plot",
    "absorption_comparison_table",
    "coherent_comparison_table",
    "incoherent_comparison_table",
    "total_comparison_table",
    "energy_dependent_table",
    "sld_table",
    "neutron_sld_from_atoms",
]
ABSORPTION_WAVELENGTH = ...
ENERGY_FACTOR = ...
VELOCITY_FACTOR = ...

def neutron_wavelength(energy):  # -> NDArray[Any]:
    r"""
    Convert neutron energy to wavelength.

    :Parameters:
        *energy* \: float or vector | meV

    :Returns:
        *wavelength* \: float or vector | |Ang|

    Energy is converted to wavelength using

    .. math::

        E = 1/2 m_n v^2 = h^2 / (2 m_n \lambda^2)
        \Rightarrow \lambda = \sqrt{h^2 / (2 m_n E)}

    where

        $h$ = planck's constant in |Js|

        $m_n$ = neutron mass in kg

    """

def neutron_wavelength_from_velocity(velocity):
    r"""
    Convert neutron velocity to wavelength.

    :Parameters:
        *velocity* \: float or vector | m/s

    :Returns:
        *wavelength* \: float or vector | |Ang|

    Velocity is converted to wavelength using

    .. math::

        \lambda = h/p = h/(m_n v)

    where

        $h$ = planck's constant in |Js|

        $m_n$ = neutron mass in kg
    """

def neutron_energy(wavelength):  # -> NDArray[floating[Any]]:
    r"""
    Convert neutron wavelength to energy.

    :Parameters:
        *wavelength* \: float or vector | |Ang|

    :Returns:
        *energy* \: float or vector | meV

    Wavelength is converted to energy using

    .. math::

        E = 1/2 m_n v^2 = h^2 / (2 m_n \lambda^2)

    where:

        $h$ = planck's constant in |Js|

        $m_n$ = neutron mass in kg
    """

_4PI_100 = ...

class Neutron:
    r"""
    Neutron scattering factors are attached to each element in the periodic
    table for which values are available.  If no information is available,
    then the neutron field of the element will be *None*. Even when neutron
    information is available, it may not be complete, so individual fields
    may be *None*.

    The following fields are defined:

    * b_c (fm)
        Bounds coherent scattering length.

    * total (barn)
        Total scattering cross section $\sigma_s$.  This does not include the
        absorption cross section.  To compute the total collision cross
        section use $\sigma_t = \sigma_s + \sigma_a$

    * absorption (barn)
        Absorption cross section $\sigma_a$ at 1.798 |Ang|.  Scale to your beam
        by dividing by periodictable.nsf.ABSORPTION_WAVELENGTH and multiplying
        by your wavelength.

    * b_c_complex (fm)
        Complex coherent scattering length derived from the tabulated
        values using $b_c - i \sigma_a / (1000 \cdot 2 \lambda)$.

    Additional columns not used for calculation include:

    * b_c_i (fm)
        Imaginary bound coherent scattering length.  This is related to
        absorption cross section by $\sigma_a = 4 \pi \mathrm{Im}(b_c)/k$ where
        $k = 2 \pi/\lambda$ and an additional factor of 1000 for converting
        between |Ang|\ |cdot|\ fm and barns.  b_c_i is not available for
        all isotopes for which absorption cross sections have been measured.

    * bp, bm (fm)
        Spin-dependent scattering for I+1/2 and I-1/2 (not always available).
        Incoherent scattering arises from the spin-dependent scattering b+
        and b-. The Neutron Data Booklet\ [#Rauch2003]_ gives formulas for
        calculating coherent and incoherent scattering from b+ and b- alone.

    * bp_i, bm_i (fm)
        Imaginary portion of bp and bm.

    * is_energy_dependent (boolean)
        Do not use this data if scattering is energy dependent.

    * coherent (barn)
        Coherent scattering cross section.  This is tabulated but not used.
        In theory coherent scattering is related to bound coherent scattering
        by $\sigma_c = 4 \pi |\mathrm{Re}(b_c) + i \mathrm{Im}(b_c)|^2/100$.
        In practice, these values are different, with the following table
        showing the largest relative difference:

        ========  ========  ========  ========  ========
        Sc   3%   Ti   4%   V   34%   Mn   1%   Cd  2%
        Te   4%   Xe   9%   Sm  19%   Eu  44%   Tb  1%
        Ho  11%   W    4%   Au   7%   Hg   2%   Ra  3%
        ========  ========  ========  ========  ========

    * incoherent (barn)
        Incoherent scattering cross section $\sigma_i$.  This is tabulated but
        not used. Instead, the incoherent cross section is computed from the
        total cross section minus the coherent cross section even for single
        atoms so that results from compounds are consistent with results from
        single atoms.

    For elements, the scattering cross-sections are based on the natural
    abundance of the individual isotopes. Individual isotopes may have
    the following additional fields

    * abundance (%)
        Isotope abundance used to compute the properties of the element in
        natural abundance.

    * nuclear_spin (string)
        Spin on the nucleus: '0', '1/2', '3/2', etc.

    Each field ``T`` above has a corresponding ``T_units`` attribute with
    the name of the units.

    For scattering calculations the scattering length density is the value
    of interest. This is computed from the *number_density* of the individual
    elements, as derived from the element density and atomic mass.

    .. Note:: 1 barn = 100 |fm^2|
    """

    b_c = ...
    b_c_units = ...
    b_c_i = ...
    b_c_i_units = ...
    b_c_complex = ...
    b_c_complex_units = ...
    bp = ...
    bp_i = ...
    bp_units = ...
    bm = ...
    bm_i = ...
    bm_units = ...
    coherent = ...
    coherent_units = ...
    incoherent = ...
    incoherent_units = ...
    total = ...
    total_units = ...
    absorption = ...
    absorption_units = ...
    abundance = ...
    abundance_units = ...
    is_energy_dependent = ...
    nsf_table = ...
    def __init__(self) -> None: ...
    def has_sld(self):  # -> bool:
        """Returns *True* if sld is defined for this element/isotope."""
    def scattering_by_wavelength(self, wavelength):  # -> tuple[Unknown, Unknown]:
        r"""
        Return scattering length and total cross section for each wavelength.

        For rare earth isotopes this returns the energy-dependent
        $\mathrm{Re}(b_c)$ and $\mathrm{Im}(b_c)$ interpolated into the
        scattering length tables. Values are extrapolated with constant
        values at the ends of the table. Total scattering is returned as
        $4\pi/100 |b_c|^2$ with no contribution for bound incoherent
        scattering.

        :Parameters:
            *wavelength* \: float(s) | |Ang|

        :Returns:
            *b_c* \: complex(s) | fm

            *sigma_s* \: float(s) | barn
        """
    @require_keywords
    def sld(
        self, wavelength=...
    ):  # -> tuple[None, None, None] | tuple[Unknown, Unknown, Unknown] | None:
        r"""
        Returns scattering length density for the element at natural
        abundance and density.

        :Parameters:
            *wavelength* \: float(s) | |Ang|

        :Returns:
            *sld* \: float(s), float(s), float(s) | |1e-6/Ang^2|
                (*real*, -*imaginary*, *incoherent*) scattering length density.

        Returns (None, None, None) if sld is not known for this element.

        See :func:`neutron_scattering` for details.
        """
    @require_keywords
    def scattering(
        self, wavelength=...
    ):  # -> tuple[None, None, None] | tuple[tuple[Unknown, Unknown, Unknown], tuple[Unknown, Unknown, Unknown], Unknown]:
        r"""
        Returns neutron scattering information for the element at natural
        abundance and density.

        :Parameters:
            *wavelength* \: float(s) | |Ang|

        :Returns:
            *sld* \: float(s), float(s), float(s) | |1e-6/Ang^2|
                (*real*, -*imaginary*, *incoherent*) scattering length density

            *xs* \: float(s), float(s), float(s) | |1/cm|
                (*coherent*, *absorption*, *incoherent*) cross sections.
                :w

            *penetration* \: float(s) | cm
                1/e penetration length.

        Returns (None, None, None) if sld is not known for this element.

        See :func:`neutron_scattering` for details.
        """

def energy_dependent_init(table): ...
def init(table, reload=...):  # -> None:
    """
    Loads the Rauch table from the neutron data book.
    """

@require_keywords
def neutron_scattering(
    compound,
    density=...,
    wavelength=...,
    energy=...,
    natural_density=...,
    table=...,
):  # -> tuple[None, None, None] | tuple[tuple[Literal[0], Literal[0], Literal[0]], tuple[Literal[0], Literal[0], Literal[0]], float] | tuple[tuple[Unknown, Unknown, Unknown], tuple[Unknown, Unknown, Unknown], Unknown]:
    r"""
    Computes neutron scattering cross sections for molecules.

    :Parameters:
        *compound* \: Formula initializer
            Chemical formula
        *density* \: float | |g/cm^3|
            Mass density
        *natural_density* \: float | |g/cm^3|
            Mass density of formula with naturally occuring abundances
        *wavelength* 1.798 \: float(s) | |Ang|
            Neutron wavelength (default=1.798 |Ang|).
        *energy* \: float(s) | meV
            Neutron energy.  If energy is specified then wavelength is ignored.
        *table* \: PeriodicTable
            Alternate table to use when parsing *compound*.

    :Returns:
        *sld* \: float(s), float(s), float(s) | |1e-6/Ang^2|
            (*real*, -*imaginary*, *incoherent*) scattering length density.
        *xs* \: float(s), float(s), float(s) | |1/cm|
            (*coherent*, *absorption*, *incoherent*) cross sections.
        *penetration* \: float(s) | cm
            1/e penetration depth of the beam

    Returns (None, None, None) if sld is unknown for any component.

    :Raises:
        *AssertionError* \: density is missing.


    .. Note:

        The returned values will be vectors if *wavelength* is a vector.

    Neutron scattering cross sections for materials are calculated from
    tabulated values for the different nuclei. The result is only an
    approximation. Actual scattering depends on details of sample composition,
    as well as the incoming neutron energy and sample temperature, especially
    for light elements. For low energy neutrons the tabulated
    cross sections are generally a lower limit. The measured incoherent
    scattering from hydrogen, for example, can be considerably larger
    (by more than 20%) than its bound value, leading to an estimate of 5.621/cm
    for H2O as computed compared to ~7.0/cm as measured with 5 meV neutrons
    at 290K.\ [#May1982]_ The alignment of the neutron spin with the nuclei
    spin also matters, as demonstrated by $^3\mathrm{He}$ polarizers.

    The tables themselves are not self-consistent.  Because the different
    quantities are measured indirectly with a variety of techniques, there
    are discrepencies when converting values from one column to another. These
    differences can be seen with the following:

        :func:`absorption_comparison_table`

        :func:`coherent_comparison_table`

        :func:`total_comparison_table`

    For our calculations we use the real part of the bound coherent scattering
    length $\mathrm{Re}(b_c)$ (labelled b_c in the tables) and the absorption
    cross section $\sigma_a$ from which we derive the imaginary scattering
    length, $\mathrm{Im}(b_c)$. See Sears (1992) for details.\ [#Sears1992]_

    We first need to average quantities for the unit cell of the molecule.
    Molar mass *m* (g/mol) is the sum of the masses of each component:

    .. math::

        m = \sum{n_k m_k}\ {\rm for\ each\ atom}\ k=1,2,\ldots

    Cell volume $V$ (|Ang^3|/molecule) is molar mass $m$ over density
    $\rho$, with a correction based on Avogadro's number $N_A$ (atoms/mol)
    and the length conversion $10^8$ |Ang|/cm:

    .. math::

        V = m/\rho \cdot 1/N_A \cdot (10^8)^3

    Number density $N$ is the number of scatterers per unit volume:

    .. math::

        N = \left.\sum{n_k} \right/ V

    The coherent scattering length of the molecule is computed from the
    average scattering length $b_c = \mathrm{Re}(b_c) + i \mathrm{Im}(b_c)$
    weighted by frequency:

    .. math::

        \mathrm{Re}(b_c) &= \left.\sum n_k \mathrm{Re}(b_{ck}) \right/ \sum n_k \\
        \mathrm{Im}(b_c) &= \left.\sum n_k \mathrm{Im}(b_{ck}) \right/ \sum n_k

    The individual $\mathrm{Im}(b_{ck})$ values are derived from the absorption
    cross sections $\sigma_a$, tabulated at wavelength $\lambda = 1.798$ |Ang|
    and scaled to fm (with 1000 fm = 1 barn/|Ang|):

    .. math::

        \mathrm{Im}(b_{ck}) = -\left. \sigma_{ak} \right/ (1000 \cdot 2 \lambda)

    Note the sign change relative to $b''$ in Sears (1992), with Eq 2
    defining $b = b' - i b''$. Since we are not considering polarized
    nuclei, the imaginary incoherent contribution is zero and
    $b'' = -\mathrm{Im}(b_c)$.

    Some rare earth isotopes are energy-dependent with complex bound coherent
    scattering length $b_c$ tabulated by energy.\ [#Lynn1990]_ For the given
    input wavelength $\lambda$, $b_c$ is interpolated from the table values,
    with the end points used for values outside the tabulated range.

    The average scattering length is converted to scattering cross
    sections, with $\sigma_c$ scaled to barn (with 1 barn= 100 |fm^2|)
    and $\sigma_a$ scaled to barn (with 1000 barn = 1 fm |Ang|):

    .. math::

        \sigma_c &= \left. 4 \pi |\mathrm{Re}(b_c) + i \mathrm{Im}(b_c)|^2 \right/ 100 \\
        \sigma_a &= -\left. 1000 \cdot 4 \pi \left< \mathrm{Im}(b_c) \right> \right/k
            \ {\rm for} \ k=2\pi / \lambda

    For most elements the scattering length is independent of energy in
    the thermal neutron energy range so the coherent scattering length
    $\sigma_c$ is unchanged. The absorption cross section $\sigma_a$ for
    these elements scales linearly with wavelength and can be adjusted
    with a simple multiplication:

    .. math::

        \sigma_a' = \sigma_a \lambda' / \lambda_o = \sigma_a \lambda' / 1.798

    The incoherent scattering length is more complicated, including
    contributions from spin incoherence for different possible spin states
    as well as isotope incoherence from diffuse coherent
    scattering.\ [#Glinka2011]_ Using the total cross section $\sigma_s$ from
    the table, the incoherent scattering length is estimated as:

    .. math::

        \sigma_s &= \left.\sum n_k \sigma_{sk} \right/ \sum n_k \\
        \sigma_i &= \sigma_s - \sigma_c \\
        b_i &= \sqrt{ 100 \sigma_i / (4 \pi) }

    For the energy dependent rare earth isotopes the total scattering is
    estimated from $b = \mathrm{Re}(b_c) + i \mathrm{Im}(b_c)$, ignoring
    any spin incoherence effects. As a result, incoherent scattering for
    materials with energy-dependent rare earth isotopes with non-zero
    nuclear spin will be underestimated.

    The scattering potential can be expressed as a scattering length
    density (SLD).  This is the number density of the scatterers
    (per $\AA^3$) times their scattering lengths, scaled to
    $10^6/\AA^2$ (with $1/\AA^2$ = $10^{5} \mathrm{fm}/\AA^3$).
    Following the convention of Sears (1992), we define sld as
    $\rho = \rho_{\rm re} - i \rho_{\rm im}$.

    .. math::

        \rho_{\rm re} (10^6 / \AA^2) &= 10 N \mathrm{Re}(b_c) \\
        \rho_{\rm im} (10^6 / \AA^2) &= -10 N \mathrm{Im}(b_c) \\
        \rho_{\rm inc} (10^6 / \AA^2) &= 10 N b_i

    Similarly, the macroscopic scattering cross section for the sample includes
    number density:

    .. math::

        \Sigma_{\rm coh} (1/{\rm cm}) &= N \sigma_c \\
        \Sigma_{\rm inc} (1/{\rm cm}) &= N \sigma_i \\
        \Sigma_{\rm abs} (1/{\rm cm}) &= N \sigma_a \\
        \Sigma_{\rm s} (1/{\rm cm}) &= N \sigma_s

    The 1/e penetration depth $t_u$ represents the the depth into the sample
    at which the unscattered intensity is reduced by a factor of $e$:

    .. math::

        t_u (cm) = \left. 1 \right/ (\Sigma_{\rm s} + \Sigma_{\rm abs})

    The calculated penetration depth includes the effects of both
    absorption and incoherent scattering (which spreads the beam over the
    full $4\pi$ spherical surface, and so it looks like absorption with
    respect to the beam), as well as the coherent scattering from the sample.
    If you instead want to calculate the effective shielding of the sample,
    you should recalculate penetration depth with absorption only.

    Transmission rate can be computed from $e^{-d/t_u}$ for penetration
    depth $t_u$ and sample thickness $d$. This does not include many
    real world effects, such as single phonon scattering\ [#Mildner1998]_
    and forward scattering\ [#May1982]_, which result in measured
    transmission significantly different from the values predicted from
    nuclear properties alone.

    There is also a wavelength dependence for single phonon interactions which
    gives rise to significant inelastic scattering for lighter isotopes (H, D)
    and/or longer wavelengths (above 5 |Ang|). This factor is both
    temperature and material dependent and will not be included
    in the scattering calculations. In particular, penetration length and
    transmitted flux are going to be significantly overestimated.

    Including unit conversion with $\mu=10^{-6}$ the full scattering equations
    are:

    .. math::

        \rho_{\rm re}\,(\mu/\AA^2) &= (N/\AA^3)
            \, (\mathrm{Re}(b_c)\,{\rm fm})
            \, (10^{-5} \AA/{\rm\,fm})
            \, (10^6\,\mu) \\
        \rho_{\rm im}\,(\mu/\AA^2) &= (N/\AA^3)
            \, (\sigma_a\,{\rm barn})
            \, (10^{-8}\,\AA^2/{\rm barn}) / (2 \lambda\, \AA)
            \, (10^6\,\mu) \\
            &= (N/\AA^3)
            \, (-\mathrm{Im}(b_c)\,{\rm fm})
            \, (10^{-5} \AA/{\rm\,fm})
            \, (10^6\,\mu) \\
        \rho_{\rm inc}\,(\mu/\AA^2) &= (N/\AA^3)
            \, \sqrt{(\sigma_i\, {\rm barn})/(4 \pi)
                \, (100\, {\rm fm}^2/{\rm barn})}
            \, (10^{-5}\, \AA/{\rm fm})
            \, (10^6\, \mu) \\
        \Sigma_{\rm coh}\,(1/{\rm cm}) &= (N/\AA^3)
            \, (\sigma_c\, {\rm barn})
            \, (10^{-8}\, \AA^2/{\rm barn})
            \, (10^8\, \AA/{\rm cm}) \\
        \Sigma_{\rm inc}\,(1/{\rm cm}) &= (N/\AA^3)
            \,(\sigma_i\, {\rm barn})
            \, (10^{-8}\, \AA^2/{\rm barn})
            \, (10^8\, \AA/{\rm cm}) \\
        \Sigma_{\rm abs}\,(1/{\rm cm}) &= (N/\AA^3)
            \,(\sigma_a\,{\rm barn})
            \, (10^{-8}\, \AA^2/{\rm barn})
            \, (10^8\, \AA/{\rm cm}) \\
        \Sigma_{\rm s}\,(1/{\rm cm}) &= (N/\AA^3)
            \,(\sigma_s\,{\rm barn})
            \, (10^{-8}\, \AA^2/{\rm barn})
            \, (10^8\, \AA/{\rm cm}) \\
        t_u\,({\rm cm}) &= 1/(\Sigma_{\rm s}\, 1/{\rm cm}
            \,+\, \Sigma_{\rm abs}\, 1/{\rm cm})
    """

def neutron_sld(
    *args, **kw
):  # -> tuple[Literal[0], Literal[0], Literal[0]] | tuple[Unknown, Unknown, Unknown] | None:
    r"""
    Computes neutron scattering length densities for molecules.

    :Parameters:
        *compound* \: Formula initializer
            Chemical formula
        *density* \: float | |g/cm^3|
            Mass density
        *natural_density* \: float | |g/cm^3|
            Mass density of formula with naturally occuring abundances
        *wavelength* \: float | |Ang|
            Neutron wavelength (default=1.798 |Ang|).
        *energy* \: float | meV
            Neutron energy.  If energy is specified then wavelength is ignored.
        *table* \: PeriodicTable
            Alternate table to use when parsing *compound*.
    :Returns:
        *sld* \: (float, float, float) | |1e-6/Ang^2|
            (*real*, -*imaginary*, *incoherent*) scattering length density.

    :Raises:
        *AssertionError* \: density is missing.

    Returns the scattering length density of the compound.
    See :func:`neutron_scattering` for details.
    """

def neutron_sld_from_atoms(
    *args, **kw
):  # -> tuple[Literal[0], Literal[0], Literal[0]] | tuple[Unknown, Unknown, Unknown] | None:
    r"""
    .. deprecated:: 0.91

        :func:`neutron_sld` accepts dictionaries of \{atom\: count\}.

    """

def D2O_match(compound, **kw):  # -> tuple[Unknown | float, Unknown]:
    """
    Find the D2O contrast match point for the compound.

    *wavelength* or *energy* select neutron wavelength or energy.

    Additional keyword arguments (*density*, *natural_density*, *name*, *table*)
    are passed to :func:`formulas.formula` when parsing the compound.

    Returns *D2O_fraction* and *SLD* at match point.

    See :func:`D2O_sld` for details on the calculation.

    Note that the resulting fraction is only meaningful in [0, 1]. Beyond
    100% you will need an additional constrast agent in the 100% D2O
    solvent to increase the SLD enough to match.
    """

def D2O_sld(
    compound, volume_fraction=..., D2O_fraction=..., **kw
):  # -> tuple[Unknown, ...]:
    """
    Compute the neutron SLD for a D2O contrast solution.

    *compound* is a string or parsed formula object. Labile hydrogen should
    be marked as H[1] in the formula. These will be substituted according to
    %D2O in the solvent.

    The D2O contrast mixture is assumed to be made using pure H2O (with
    its natural H:D ratios) and pure D2O with no H present, so H[1] will be
    substituted alternately with H and D when computing mixture SLD.
    Solvent SLD is calculated using the density at 20 C.

    Only the coherent scattering crosssection will be matched. Incoherent
    and absorption crosssections are likely to be different for the compound
    and the solvent, especially due to the large incoherent crosssection for
    hydrogen.

    Note that incoherent scattering does not mix linearly, so the incoherent
    sld for the mixture will differ slightly from incoherent scattering
    computed returned from a compound with the same isotope ratios.

    *volume_fraction* is the portion by volume of solute in the solution.

    *D2O_fraction* is the portion by volume of D2O in the solvent.

    *wavelength* or *energy* to select neutron wavelength or energy.

    Additional keyword arguments (*density*, *natural_density*, *name*, *table*)
    are passed to :func:`formulas.formula` when parsing the compound.

    Returns (real, imag, incoh) SLD.
    """

def mix_values(a, b, fraction):  # -> tuple[Unknown, ...]:
    """
    Mix two tuples with floating point values according to fraction of a.
    """

def neutron_composite_sld(
    materials, wavelength=...
):  # -> (weights: Unknown, density: int = 1) -> (tuple[Literal[0], Literal[0], Literal[0]] | tuple[Unknown, Unknown, Unknown]):
    r"""
    Create a composite SLD calculator.

    :Parameters:
        *materials* \: [Formula]
            List of materials
        *wavelength* = 1.798: float OR [float] | |Ang|
            Probe wavelength(s).

    :Returns:
        *calculator* \: f(w, density=1) -> (*real*, -*imaginary*, *incoherent*)

    The composite calculator takes a vector of weights and returns the
    scattering length density of the composite.  This is useful for operations
    on large molecules, such as calculating a set of contrasts or fitting
    a material composition. Note that density must be provided for each set
    of material weights. The density on the individual materials is ignored.

    The returned slds will be vectors if the input wavelength is a vector
    and if any of the elements are energy dependent.

    Table lookups and partial sums and constants are precomputed so that
    the calculation consists of a few simple array operations regardless
    of the size of the material fragments.
    """

def sld_plot(table=...):  # -> None:
    r"""
    Plots SLD as a function of element number.

    :Parameters:
        *table* \: PeriodicTable
            The default periodictable unless a specific table has been requested.

    :Returns: None
    """

nsftable = ...
nsftableI = ...

def fix_number(str):  # -> float | None:
    """
    Converts strings of the form e.g., 35.24(2)* into numbers without
    uncertainty. Also accepts a limited range, e.g., <1e-6, which is
    converted as 1e-6.  Missing values are set to 0.
    """

def sld_table(wavelength=..., table=..., isotopes=...):  # -> None:
    r"""
    Scattering length density table for wavelength 4.75 |Ang|.

    :Parameters:

        *table* \: PeriodicTable
            If *table* is not specified, use the common periodic table.

        *isotopes* = True \: boolean
            Whether to consider isotopes or not.

    :Returns: None

    Example

        >>> sld_table(wavelength=4.75)  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
         Neutron scattering length density table
        atom       mass density     sld    imag   incoh
        H         1.008   0.071  -1.582   0.000  10.691
        1-H       1.008   0.071  -1.583   0.000  10.691
        D         2.014   0.141   2.823   0.000   1.705
        T         3.016   0.212   2.027   0.000   0.453
        He        4.003   0.122   0.598   0.000   0.035
        3-He      3.016   0.092   1.054   0.272   0.652 *
        4-He      4.003   0.122   0.598   0.000   0.035
           ...
        248-Cm  248.072  13.569   2.536   0.000   0.207
        * Energy dependent cross sections
    """

def energy_dependent_table(table=...):  # -> None:
    r"""
    Prints a table of energy dependent isotopes.

    :Parameters:
        *table* \: PeriodicTable
            If *table* is not specified, use the common periodic table.

    :Returns: None

    Example

        >>> energy_dependent_table()
        Elements and isotopes with energy dependent absorption:
            He-3
            Cd Cd-113
            Sm Sm-149
            Eu Eu-151
            Gd Gd-155 Gd-157
            Yb-168
            Hg-196 Hg-199
    """

def compare(fn1, fn2, table=..., tol=...): ...
def absorption_comparison_table(table=..., tol=...):  # -> None:
    r"""
    Prints a table comparing absorption to the imaginary bound coherent
    scattering length b_c_i.  This is used to checking the integrity
    of the data and formula.

    The relationship between absorption and b_c_i is:

    .. math::

        \sigma_a = -2 \lambda \mathrm{Im}(b_c) \cdot 1000

    The wavelength $\lambda = 1.798 \AA$ is the neutron wavelength at which
    the absorption is tallied. The factor of 1000 transforms from
    |Ang|\ |cdot|\ fm to barn.

    :Parameters:
        *table* \: PeriodicTable
            The default periodictable unless a specific table has been requested.
        *tol* = 0.01 \: float | barn
            Show differences greater than this amount.

    :Returns: None

    Example

        >>> absorption_comparison_table(
        ...     tol=0.5
        ... )  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
        Comparison of absorption and (-2000 lambda b_c_i)
              3-He  5333.00  5322.08   0.2%
                Li    70.50     ----
              6-Li   940.00   934.96   0.5%
                 B   767.00   755.16   1.6%
              10-B  3835.00     ----
                 N     1.90     ----
           ...

    """

def coherent_comparison_table(table=..., tol=...):  # -> None:
    r"""
    Prints a table of $4 \pi |b_c|^2/100$ and coherent for each isotope.
    This is useful for checking the integrity of the data and formula.

    The table only prints where b_c exists.

    :Parameters:
        *table* \: PeriodicTable
            The default periodictable unless a specific table has been requested.
        *tol* = 0.01 \: float | barn
            Amount of difference to show. Use -tol to show elements within
            tolerance rather than those outside tolerance.

    :Returns: None

    Example

        >>> coherent_comparison_table(
        ...     tol=0.5
        ... )  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
        Comparison of (4 pi |b_c|^2/100) and coherent
                 n   172.03    43.01 300.0%
               1-n   172.03    43.01 300.0%
                Sc    18.40    19.00  -3.2%
             45-Sc    18.40    19.00  -3.2%
             65-Cu    13.08    14.10  -7.2%
             70-Zn     5.98     4.50  33.0%
             84-Sr     3.14     6.00 -47.6%
           ...

    """

def total_comparison_table(table=..., tol=...):  # -> None:
    r"""
    Prints a table of neutron.total and sum coh,inc for each
    isotope where these exist.  This is used to checking the integrity
    of the data and formula.

    :Parameters:
        *table* \: PeriodicTable
            The default periodictable unless a specific table has been requested.
        *tol* = 0.01 \: float | barn
            Amount of difference to show. Use -tol to show elements within
            tolerance rather than those outside tolerance.

    :Returns: None

    Example

        >>> total_comparison_table(tol=0.1)
        Comparison of total cross section to (coherent + incoherent)
                 n    43.01     ----
               1-n    43.01     ----
             84-Kr     6.60     ----
            149-Sm   200.00   200.50  -0.2%
                Eu     9.20     9.07   1.4%
                Gd   180.00   180.30  -0.2%
            155-Gd    66.00    65.80   0.3%
            161-Dy    16.00    16.30  -1.8%
            180-Ta     7.00     6.70   4.5%
            187-Os    13.00    13.30  -2.3%

    """

def incoherent_comparison_table(table=..., tol=...):  # -> None:
    r"""
    Prints a table of incoherent computed from total and b_c with incoherent.

    :Parameters:
        *table* \: PeriodicTable
            The default periodictable unless a specific table has been requested.
        *tol* = 0.01 \: float | barn
            Amount of difference to show. Use -tol to show elements within
            tolerance rather than those outside tolerance.

    :Returns: None

    Example

        >>> incoherent_comparison_table(
        ...     tol=0.5
        ... )  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
        Comparison of incoherent and (total - 4 pi |b_c|^2/100)
                Sc     4.50     5.10 -11.8%
             45-Sc     4.50     5.10 -11.8%
             65-Cu     0.40     1.42 -71.7%
             70-Zn     0.00    -1.48 -100.0%
             84-Sr     0.00     2.86 -100.0%
           ...

    """

def print_scattering(compound, wavelength=...):  # -> None:
    """
    Print the scattering for a single compound.
    """

def main():  # -> None:
    """
    Simple command line interface, showing the predicted neutron scattering.

    Usage::

        python -m periodictable.nsf [-Lwavelength] compound@density compound@density ...

    For example::

        $ python -m periodictable.nsf XeF6@3.56
        scattering for XeF6 at 1.798 Ang  (density=3.56 g/cm^3)
          sld: 3.37503 + 0.000582313 j  (0.402605 incoherent)  1e-6/Ang^2
          sigma_c: 3.37503  sigma_i: 0.000582313  sigma_a: 0.402605  1/cm
          1/e penetration: 2.23871 cm
    """

if __name__ == "__main__": ...
