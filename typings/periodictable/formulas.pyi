"""
This type stub file was generated by pyright.
"""

from __future__ import annotations

from .util import require_keywords

"""
Chemical formula parser.
"""
PACKING_FACTORS = ...

def mix_by_weight(*args, **kw):  # -> Formula:
    """
    Generate a mixture which apportions each formula by weight.

    :Parameters:
        *formula1* : Formula OR string
            Material

        *quantity1* : float
            Relative quantity of that material

        *formula2* : Formula OR string
            Material

        *quantity2* : float
            Relative quantity of that material

        ...

        *density* : float
            Density of the mixture, if known

        *natural_density* : float
            Density of the mixture with natural abundances, if known.

        *name* : string
            Name of the mixture

        *table* : PeriodicTable
            Private table to use when parsing string formulas.

    :Returns:

        *formula* : Formula

    If density is not given, then it will be computed from the density
    of the components, assuming the components take up no more nor less
    space because they are in the mixture.  If component densities are
    not available, then the resulting density will not be computed.  The
    density calculation assumes the cell volume remains constant for the
    original materials, which is not in general the case.
    """

def mix_by_volume(*args, **kw):  # -> Formula:
    """
    Generate a mixture which apportions each formula by volume.

    :Parameters:
        *formula1* : Formula OR string
            Material

        *quantity1* : float
            Relative quantity of that material

        *formula2* : Formula OR string
            Material

        *quantity2* : float
            Relative quantity of that material

        ...

        *density* : float
            Density of the mixture, if known

        *natural_density* : float
            Density of the mixture with natural abundances, if known.

        *name* : string
            Name of the mixture

        *table* : PeriodicTable
            Private table to use when parsing string formulas.

    :Returns:

        *formula* : Formula

    If density is not given, then it will be computed from the density
    of the components, assuming the components take up no more nor less
    space because they are in the mixture.  If component densities are
    not available, then a ValueError is raised. The  density calculation
    assumes the cell volume remains constant for the original materials,
    which is not in general the case.
    """

def formula(compound=..., density=..., natural_density=..., name=..., table=...):
    r"""
    Construct a chemical formula representation from a string, a
    dictionary of atoms or another formula.

    :Parameters:
        *compound* : Formula initializer
            Chemical formula.

        *density* : float | |g/cm^3|
            Material density.  Not needed for single element formulas.

        *natural_density* : float | |g/cm^3|
            Material density assuming naturally occurring isotopes and no
            change in cell volume.

        *name* : string
            Common name for the molecule.

        *table* : PeriodicTable
            Private table to use when parsing string formulas.

    :Exceptions:
        *ValueError* : invalid formula initializer

    After creating a formula, a rough estimate of the density can be
    computed using::

        formula.density = formula.molecular_mass / formula.volume(packing_factor=...)

    The volume() calculation uses the covalent radii of the components and
    the known packing factor or crystal structure name.  If the lattice
    constants for the crystal are known, then they can be used instead::

        formula.density = formula.molecular_mass / formula.volume(
            a, b, c, alpha, beta, gamma
        )

    Formulas are designed for calculating quantities such as molar mass and
    scattering length density, not for representing bonds or atom positions.
    The representations are simple, but preserve some of the structure for
    display purposes.
    """

class Formula:
    """
    Simple chemical formula representation.

    """

    def __init__(
        self, structure=..., density=..., natural_density=..., name=...
    ) -> None: ...
    @property
    def atoms(self):  # -> dict[Unknown, Unknown]:
        """
        { *atom*: *count*, ... }

        Composition of the molecule.  Referencing this attribute computes
        the *count* as the total number of each element or isotope in the
        chemical formula, summed across all subgroups.
        """
    @property
    def hill(self):
        """
        Formula

        Convert the formula to a formula in Hill notation.  Carbon appears
        first followed by hydrogen then the remaining elements in alphabetical
        order.
        """
    def natural_mass_ratio(self):  # -> float:
        """
        Natural mass to isotope mass ratio.

        :Returns:
            *ratio* : float

        The ratio is computed from the sum of the masses of the individual
        elements using natural abundance divided by the sum of the masses
        of the isotopes used in the formula.  If the cell volume is
        preserved with isotope substitution, then the ratio of the masses
        will be the ratio of the densities.
        """
    @property
    def natural_density(self):
        """
        |g/cm^3|

        Density of the formula with specific isotopes of each element
        replaced by the naturally occurring abundance of the element
        without changing the cell volume.
        """
    @natural_density.setter
    def natural_density(self, natural_density): ...
    @property
    def mass(self):  # -> Literal[0]:
        """
        atomic mass units u (C[12] = 12 u)

        Molar mass of the molecule.  Use molecular_mass to get the mass in
        grams.
        """
    @property
    def molecular_mass(self):  # -> float:
        """
        g

        Mass of the molecule in grams.
        """
    @property
    def charge(self):  # -> int:
        """
        Net charge of the molecule.
        """
    @property
    def mass_fraction(self):  # -> dict[Unknown, Unknown]:
        """
        Fractional mass representation of each element/isotope/ion.
        """
    def volume(self, *args, **kw):
        r"""
        Estimate unit cell volume.

        The crystal volume can be estimated from the element covalent radius
        and the atomic packing factor using::

            packing_factor = N_atoms V_atom / V_crystal

        Packing factors for a number of crystal lattice structures are defined.

        .. table:: Crystal lattice names and packing factors

         ======== ======================= ====================== ==============
         Code     Description             Formula                Packing factor
         ======== ======================= ====================== ==============
         cubic    simple cubic            $\pi/6$                0.52360
         bcc      body-centered cubic     $\pi\sqrt{3/8}$        0.68017
         hcp      hexagonal close-packed  $\pi/\sqrt{18}$        0.74048
         fcc      face-centered cubic     $\pi/\sqrt{18}$        0.74048
         diamond  diamond cubic           $\pi\sqrt{3/16}$       0.34009
         ======== ======================= ====================== ==============

        :Parameters:
            *packing_factor*  = 'hcp' : float or string
                Atomic packing factor.  If *packing_factor* is the name of
                a crystal lattice, use the *lattice* packing factor.
            *a*, *b*, *c* : float | |Ang|
                Lattice spacings. *b* and *c* default to *a*.
            *alpha*, *beta*, *gamma* : float | |deg|
                Lattice angles.  These default to 90\ |deg|

        :Returns:

            *volume* : float | |cm^3|
                Molecular volume.

        :Raises:

            *KeyError* : unknown lattice type

            *TypeError* : missing or bad lattice parameters

        Using the cell volume, mass density can be set with::

            formula.density = n * formula.molecular_mass / formula.volume()

        where n is the number of molecules per unit cell.

        Note: a single non-keyword argument is interpreted as a packing factor
        rather than a lattice spacing of 'a'.
        """
    @require_keywords
    def neutron_sld(
        self, wavelength=..., energy=...
    ):  # -> tuple[None, None, None] | tuple[Literal[0], Literal[0], Literal[0]] | tuple[Unknown, Unknown, Unknown] | None:
        """
        Neutron scattering information for the molecule.

        :Parameters:
            *wavelength* : float | |Ang|
                Wavelength of the neutron beam.

        :Returns:

            *sld* : (float, float, float) | |1e-6/Ang^2|
                Neutron scattering length density is returned as the tuple
                (*real*, *imaginary*, *incoherent*), or as (None, None, None)
                if the mass density is not known.

        .. deprecated:: 0.95
            Use periodictable.neutron_sld(formula) instead.
        """
    @require_keywords
    def xray_sld(
        self, energy=..., wavelength=...
    ):  # -> tuple[None, None] | tuple[Literal[0], Literal[0]] | tuple[Unknown, Unknown]:
        """
        X-ray scattering length density for the molecule.

        :Parameters:
            *energy* : float | keV
                Energy of atom.

            *wavelength* : float | |Ang|
                Wavelength of atom.

            .. Note: One of *wavelength* or *energy* is required.

        :Returns:

            *sld* : (float, float) | |1e-6/Ang^2|
                X-ray scattering length density is returned as the tuple
                    (*real*, *imaginary*), or as (None, None) if the mass
                    density is not known.

        .. deprecated:: 0.95
            Use periodictable.xray_sld(formula) instead.
        """
    def change_table(self, table):  # -> Self@Formula:
        """
        Replace the table used for the components of the formula.
        """
    def replace(self, source, target, portion=...):
        """
        Create a new formula with one atom/isotope substituted for another.

        *formula* is the formula being updated.

        *source* is the isotope/element to be substituted.

        *target* is the replacement isotope/element.

        *portion* is the proportion of source which is substituted for target.
        """
    def __eq__(self, other) -> bool:
        """
        Return True if two formulas represent the same structure. Note
        that they may still have different names and densities.
        Note: use hill representation for an order independent comparison.
        """
    def __add__(self, other):  # -> Formula:
        """
        Join two formulas.
        """
    def __iadd__(self, other):  # -> Self@Formula:
        """
        Extend a formula with another.
        """
    def __rmul__(self, other):  # -> Self@Formula:
        """
        Provide a multiplier for formula.
        """
    def __repr__(self): ...

LENGTH_UNITS = ...
MASS_UNITS = ...
VOLUME_UNITS = ...
LENGTH_RE = ...
MASS_VOLUME_RE = ...

def formula_grammar(table):  # -> ParserElement:
    """
    Construct a parser for molecular formulas.

    :Parameters:

        *table* = None : PeriodicTable
             If table is specified, then elements and their associated fields
             will be chosen from that periodic table rather than the default.

    :Returns:
        *parser* : pyparsing.ParserElement.
            The ``parser.parseString()`` method returns a list of
            pairs (*count, fragment*), where fragment is an *isotope*,
            an *element* or a list of pairs (*count, fragment*).

    """

_PARSER_CACHE = ...

def parse_formula(formula_str, table=...):
    """
    Parse a chemical formula, returning a structure with elements from the
    given periodic table.
    """
